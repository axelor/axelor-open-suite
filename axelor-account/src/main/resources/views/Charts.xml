<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<object-views xmlns="http://axelor.com/xml/ns/object-views"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://axelor.com/xml/ns/object-views http://axelor.com/xml/ns/object-views/object-views_6.1.xsd">

  <custom name="report-top-3-suppliers" title="Top 3 supplier" css="report-box">
    <dataset type="jpql"><![CDATA[

	 select sum((self.operationTypeSelect + 1.5)*2*self.companyExTaxTotal) as Amount,
	 CONCAT(ceil(sum((self.operationTypeSelect + 1.5)*2*self.companyExTaxTotal)), self.company.currency.symbol) as AmountPrint,
	 _partner.name as Supplier
	 from Invoice as self
	 left join self.partner as _partner
	 where self.statusSelect = 3 and (self.company = :_company)
	 and self.operationTypeSelect in (1,2)
	 group by _partner.id, self.company.currency.symbol
	 order by Amount desc


	  ]]></dataset>
    <template><![CDATA[

	 <report-table data='data' columns='Supplier,AmountPrint'></report-table>


	  ]]></template>
  </custom>

  <custom name="invoice-terms-report-top-3-suppliers" title="Top 3 supplier" css="report-box">
    <dataset type="jpql"><![CDATA[

	 select sum(self.amount) as Amount,
	 CONCAT(ceil(sum(self.amount)), self.company.currency.symbol) as AmountPrint,
	 _partner.name as Supplier
	 from InvoiceTerm as self
	 left join self.partner as _partner
	 where (self.company = :_company) and
	 ((self.invoice.statusSelect = 3
	  and self.invoice.operationTypeSelect = 1) or (self.moveLine.move.statusSelect = 3 and
	  self.moveLine.account.accountType.technicalTypeSelect = 'payable' and self.moveLine.debit = 0))
	 group by _partner.id, self.company.currency.symbol
	 order by Amount desc

	  ]]></dataset>
    <template><![CDATA[

	 <report-table data='data' columns='Supplier,AmountPrint'></report-table>


	  ]]></template>
  </custom>

  <custom name="report-supplier-amount-remaining" title="Supplier amount in progress"
    css="report-box">
    <dataset type="jpql"><![CDATA[

	  Select  CONCAT((select sum(self.companyInTaxTotalRemaining)
	  from Invoice as self
	  WHERE self.statusSelect = 3 and (self.company = :_company)
	  and self.operationTypeSelect = 1)
	- COALESCE((select sum(self.companyInTaxTotalRemaining)
	  from Invoice as self
	  WHERE self.statusSelect = 3 and (self.company = :_company)
	  and self.operationTypeSelect = 2), 0), self.company.currency.symbol) as total
	from Invoice as self

	  ]]></dataset>
    <template><![CDATA[

	  <div class="report-data">
	    <h1>{{first.total | number : 2}}</h1>
	  </div>
	  ]]></template>
  </custom>

  <custom name="report-invoice-terms-supplier-amount-remaining"
    title="Supplier amount in progress" css="report-box">
    <dataset type="jpql"><![CDATA[

  Select  CONCAT((select sum(self.companyAmountRemaining)
  from InvoiceTerm as self
  WHERE (self.company = :_company) and ((self.moveLine.move.statusSelect in (2,3) and
  self.moveLine.account.accountType.technicalTypeSelect = 'payable' and self.moveLine.debit = 0 and self.moveLine.move.functionalOriginSelect = 4 )))
- COALESCE((select sum(self.companyAmountRemaining)
  from InvoiceTerm as self
  WHERE (self.company = :_company) and ((self.moveLine.move.statusSelect in (2,3) and
  self.moveLine.account.accountType.technicalTypeSelect = 'payable' and self.moveLine.credit = 0 and self.moveLine.move.functionalOriginSelect = 4))), 0), self.company.currency.symbol) as total
from InvoiceTerm as self

  ]]></dataset>
    <template><![CDATA[

  <div class="report-data">
    <h1>{{first.total | number : 2}}</h1>
  </div>
  ]]></template>
  </custom>



  <custom name="report-delay-rate" title="Supplier's delay on payment" css="report-box">
    <dataset type="jpql"><![CDATA[

	Select 100*(select sum((self.operationTypeSelect + 1.5) * 2 * self.companyExTaxTotal)
	 from Invoice as self
	 WHERE self.statusSelect = 3 and self.amountRemaining > 0
	 and (self.operationTypeSelect = 1 OR self.operationTypeSelect = 2) and self.dueDate <= :__date__) / (select sum((self.operationTypeSelect + 1.5)*2*self.companyExTaxTotal)
	 from Invoice as self
	 WHERE self.statusSelect = 3 and self.amountRemaining > 0
	 and (self.operationTypeSelect = 1 OR self.operationTypeSelect = 2)) as total,
	  (select sum( :__date__ - self.dueDate)
	 from Invoice as self
	 WHERE self.statusSelect = 3 and self.amountRemaining > 0
	 and (self.operationTypeSelect = 1 OR self.operationTypeSelect = 2) and self.dueDate <= :__date__) / (select count(id)
	 from Invoice as self
	 WHERE self.statusSelect = 3 and self.amountRemaining > 0
	 and (self.operationTypeSelect = 1 OR self.operationTypeSelect = 2) and self.dueDate <= :__date__) as avgdelay
	 FROM Invoice as self

	 ]]></dataset>
    <template><![CDATA[

	 <div class="report-data">
	   <h1>{{first.total | number : 2}} %</h1>

	   <small x-translate>Delay rate</small>
	   <div class="report-percent font-bold text-error pull-right">
	    <span x-translate>Average delay :</span> {{first.avgdelay | number : 2}} <span x-translate> days</span>
	   </div>
	   <div class="report-tags"><span class="label label-success" x-translate>Today</span></div>
	 </div>

	 ]]></template>
  </custom>

  <custom name="invoice-terms-report-delay-rate" title="Supplier's delay on payment"
    css="report-box">
    <dataset type="jpql"><![CDATA[

	Select 100*(select sum(self.companyAmountRemaining)
	 from InvoiceTerm as self
	 WHERE self.isPaid != true
	 and self.moveLine.move.statusSelect in (2,3) and
	  self.moveLine.account.accountType.technicalTypeSelect = 'payable' and self.moveLine.debit = 0
	  and self.moveLine.move.functionalOriginSelect = 4
	  and self.dueDate <= :__date__) / (select sum(self.companyAmountRemaining)
	 from InvoiceTerm as self
	 WHERE self.isPaid != true
	 and self.moveLine.move.statusSelect in (2,3) and
	  self.moveLine.account.accountType.technicalTypeSelect = 'payable' and self.moveLine.debit = 0
	  and self.moveLine.move.functionalOriginSelect = 4) as total,

	  (select sum( :__date__ - self.dueDate)
	 from InvoiceTerm as self
	 WHERE self.isPaid != true
	 and self.moveLine.move.statusSelect in (2,3) and
	  self.moveLine.account.accountType.technicalTypeSelect = 'payable' and self.moveLine.debit = 0
	  and self.moveLine.move.functionalOriginSelect = 4
	  and self.dueDate <= :__date__) / (select count(self.id)
	 from InvoiceTerm as self
	 WHERE self.isPaid != true
	 and self.moveLine.move.statusSelect in (2,3) and
	  self.moveLine.account.accountType.technicalTypeSelect = 'payable' and self.moveLine.debit = 0
	  and self.moveLine.move.functionalOriginSelect = 4
	  and self.dueDate <= :__date__) as avgdelay
	 FROM InvoiceTerm as self

	 ]]></dataset>
    <template><![CDATA[

	 <div class="report-data">
	   <h1>{{first.total | number : 2}} %</h1>

	   <small x-translate>Delay rate</small>
	   <div class="report-percent font-bold text-error pull-right">
	    <span x-translate>Average delay :</span> {{first.avgdelay | number : 2}} <span x-translate> days</span>
	   </div>
	   <div class="report-tags"><span class="label label-success" x-translate>Today</span></div>
	 </div>

	 ]]></template>
  </custom>

  <chart name="chart.purchases.invoice.per.month.pie"
    title="Supplier invoices by reason of refusal to pay" onInit="action.chart.set.active.company">
    <search-fields>
      <field name="_company" title="Company" type="reference"
        target="com.axelor.apps.base.db.Company"/>
    </search-fields>
    <dataset type="jpql"><![CDATA[

	  SELECT
	      SUM(self.companyInTaxTotalRemaining) AS amountRemaining,
	      _reasonOfRefusalToPay.name AS reasonOfRefusalToPayName,
	      _reasonOfRefusalToPay.id AS _reasonOfRefusalToPayNameId
	  FROM
	      Invoice self
	  LEFT JOIN
	      self.reasonOfRefusalToPay as _reasonOfRefusalToPay

	  WHERE
	      self.statusSelect in (2,3) AND (:_company is null OR self.company = :_company)
	      AND (self.operationTypeSelect = 1 OR self.operationTypeSelect = 2) AND self.pfpValidateStatusSelect = 3
	  GROUP BY
	      _reasonOfRefusalToPay.id,
	      _reasonOfRefusalToPay.name

	  ORDER BY
	      _reasonOfRefusalToPay.name

	  ]]></dataset>
    <category key="reasonOfRefusalToPayName" type="text"/>
    <series key="amountRemaining" type="pie" title="Amount"/>
    <config name="colors" value="#f63,#28a745,#007bff,#ffc107,#6c757d,#6f42c1,#17a2b8"/>
    <config name="percent" value="true"/>
    <config name="onClick" value="account.root.payments.suppl.invoices.to.pay.from.chart"/>
  </chart>

  <chart name="chart.purchases.invoice.terms.per.month.pie"
    title="Supplier invoice terms by reason of refusal to pay"
    onInit="action.chart.set.active.company">
    <search-fields>
      <field name="_company" title="Company" type="reference"
        target="com.axelor.apps.base.db.Company"/>
    </search-fields>
    <dataset type="jpql"><![CDATA[

 SELECT
     COUNT(DISTINCT self.id) AS amountRemaining,
     _reasonOfRefusalToPay.name AS reasonOfRefusalToPayName,
     _reasonOfRefusalToPay.id AS _reasonOfRefusalToPayNameId
 FROM
     InvoiceTerm self
 LEFT JOIN
     self.reasonOfRefusalToPay as _reasonOfRefusalToPay
            LEFT JOIN
              self.invoice as _invoice
            LEFT JOIN
              self.moveLine as _moveLine
            LEFT JOIN
              _moveLine.move as _move
            LEFT JOIN
              _moveLine.account as _account
            LEFT JOIN
              _account.accountType as _accountType

 WHERE
     (:_company is null OR self.company = :_company) AND self.pfpValidateStatusSelect = 3
     AND
			((_invoice.statusSelect in (2,3) AND _invoice.operationTypeSelect in (1,2))
			OR
			(_move.statusSelect in (2,3) AND _accountType.technicalTypeSelect = 'payable' AND _moveLine.debit = 0))
 GROUP BY
     _reasonOfRefusalToPay.id,
     _reasonOfRefusalToPay.name

 ORDER BY
     _reasonOfRefusalToPay.name

 ]]></dataset>
    <category key="reasonOfRefusalToPayName" type="text"/>
    <series key="amountRemaining" type="pie" title="Amount"/>
    <config name="colors" value="#f63,#28a745,#007bff,#ffc107,#6c757d,#6f42c1,#17a2b8"/>
    <config name="percent" value="true"/>
    <config name="onClick" value="action-invoice-view-show-related-invoice-terms-by-reason"/>
  </chart>


  <action-view name="account.root.payments.suppl.invoices.to.pay.from.chart"
    model="com.axelor.apps.account.db.Invoice" title="Suppl. Invoices to pay">
    <view name="invoice-supplier-grid" type="grid"/>
    <view name="invoice-form" type="form"/>
    <view-param name="search-filters" value="supplier-invoices-filters"/>
    <domain>self.operationTypeSelect in (1,2) and self.statusSelect in (2,3) and
      self.pfpValidateStatusSelect = 3 AND self.reasonOfRefusalToPay.name =
      :_reasonOfRefusalToPayName AND (:_company is null OR self.company = :_company)</domain>
    <context name="todayDate"
      expr="eval:__config__.app.getTodayDate(__user__.activeCompany)"/>
    <context name="_chart" expr="eval: _chart"/>
    <context name="_reasonOfRefusalToPayName" expr="eval: reasonOfRefusalToPayName"/>
    <context name="_company" expr="eval: _company"/>
  </action-view>

  <chart name="chart.sales.turnover.per.analytic.account.per.month"
    title="Turnover invoiced for an Analytic Axis by Month" onInit="action.chart.set.active.company">
    <search-fields>
      <field name="_company" title="Company" type="reference"
        target="com.axelor.apps.base.db.Company"/>
      <field name="_axis" title="Analytic Axis" type="reference"
        target="com.axelor.apps.account.db.AnalyticAxis"/>
    </search-fields>
    <dataset type="jpql"><![CDATA[

	  SELECT

				SUM(sign(_moveLine.credit-_moveLine.debit)*self.amount) AS amount,
				_analyticAccount.name as analyticAccountName,
	to_char(_moveLine.date,'yyyy-MM') as month
	  FROM
				AnalyticMoveLine self
	  LEFT JOIN
				self.analyticAccount as _analyticAccount
	  LEFT JOIN
	      self.moveLine as _moveLine
	  LEFT JOIN
				_moveLine.move as _move
		LEFT JOIN
				_moveLine.account as _account
	  LEFT JOIN
				self.analyticAxis as _analyticAxis
	  WHERE
	      (_move.statusSelect = 3 OR _move.statusSelect = 2) AND (:_company is null OR _move.company = :_company)
	 			AND _account.code LIKE '7%'  AND (:_axis is null OR _analyticAxis = :_axis)
	  GROUP BY
	      to_char(_moveLine.date,'yyyy-MM'),
				_analyticAccount.name
	  ORDER BY
	      month

	  ]]></dataset>
    <category key="month" type="month"/>
    <series key="amount" groupBy="analyticAccountName" type="bar"/>
    <!-- <config name="colors" value="blue,yellow,red,green" /> -->
    <config name="colors"
      value="#f63,#28a745,#007bff,#ffc107,#6c757d,#6f42c1,#17a2b8,#dc3545,#6f42c1,#f8f9fa"/>

  </chart>

  <action-record name="action.chart.set.active.company"
    model="com.axelor.apps.account.db.Invoice">
    <field name="_company" expr="eval:__repo__(User).find(__user__.id)?.activeCompany"/>
  </action-record>

  <chart name="chart.account.invoice.summary" title="Account Invoice Summary">
    <dataset type="sql">
		    <![CDATA[
			SELECT
				coalesce(SUM(_invoice._total),0.00) AS _amount,
				_meta._type AS _invoice_type
			FROM
				(SELECT company_in_tax_total_remaining AS _total, operation_type_select FROM account_invoice WHERE status_select=3) AS _invoice
			RIGHT JOIN
				(SELECT cast(value as int) AS _select_item, title AS _type
				FROM meta_select_item
				WHERE select_id IN
				(SELECT id FROM meta_select where name='iinvoice.operation.type.select')) AS _meta
			ON	_invoice.operation_type_select = _meta._select_item
			GROUP BY
				_meta._type
			ORDER BY
				_meta._type
    	    ]]>
    </dataset>
    <category key="_invoice_type" type="text" title="Invoice"/>
    <series key="_amount" type="bar" title="Amount"/>
  </chart>

  <chart name="chart.invoiced.turnover.ytd.vs.lastyear"
    title="Invoiced Turnover This year vs Last year">
    <dataset type="sql">
	    <![CDATA[
			SELECT
				SUM(CASE _invoice.operation_type_select
						WHEN 3 THEN _invoice.ex_tax_total
						WHEN 4 THEN -_invoice.ex_tax_total
						END) AS _turn_over,
				DATE_PART('year',_invoice.invoice_date) AS _year
			FROM
				account_invoice AS _invoice
			WHERE
				_invoice.status_select = 3
				AND (_invoice.operation_type_select=3 OR _invoice.operation_type_select=4)
				AND DATE_PART('year',_invoice.invoice_date)
				IN (DATE_PART('year',CURRENT_DATE) - 1, DATE_PART('year',CURRENT_DATE) )
			GROUP BY
				_year
			ORDER BY
				_year
	    ]]>
    </dataset>
    <category key="_year" type="text" title="Year"/>
    <series key="_turn_over" type="bar" title="TurnOver"/>
  </chart>

  <chart stacked="true" name="chart.invoice.turnover.cust.history"
    title="Customer Turnover history by month (on invoices)"
    onInit="action.account.chart.set.from.to.date.month">
    <search-fields>
      <field type="date" name="fromDate" title="From Date" x-required="true"/>
      <field name="toDate" type="date" title="To Date" x-required="true"/>
    </search-fields>

    <dataset type="sql">

      SELECT
      to_char(_invoice.invoice_date,'yyyy-MM') AS _month_no,
      coalesce(_product._product_type,'other') AS product,
      coalesce(SUM(CASE _operation_type
      WHEN 3
      THEN _invoice._turn_over
      WHEN 4 THEN -_invoice._turn_over
      END), 00) AS _turn_over
      FROM
      (SELECT
      _invoice.id AS _invoice_id,
      _invoice.operation_type_select AS _operation_type,
      _invoice.invoice_date as invoice_date,
      date_part('mon', _invoice.invoice_date) AS _month,
      _line.ex_tax_total AS _turn_over,
      _line.product AS _line_product
      FROM
      account_invoice AS _invoice
      JOIN
      account_invoice_line AS _line
      ON _line.invoice=_invoice.id
      JOIN
      auth_user as _user
      ON _user.id
      = :__user__
      AND _invoice.company = _user.active_company
      WHERE
      _invoice.status_select = 3
      AND
      _invoice.invoice_date BETWEEN DATE(:fromDate) AND DATE(:toDate)
      AND
      (_invoice.operation_type_select=3 OR _invoice.operation_type_select=4)

      GROUP BY
      _invoice_id,
      _line_product, _turn_over, _month) AS _invoice

      JOIN

      (SELECT
      _category.name AS _product_type,
      _product.id AS _product_id
      FROM
      base_product AS _product
      JOIN
      base_product_category AS _category
      ON _product.product_category=_category.id AND _category.name IS NOT NULL) AS _product

      ON
      _invoice._line_product=_product._product_id
      GROUP BY _month_no, _product._product_type
      ORDER BY
      _month_no, _turn_over DESC


    </dataset>
    <category key="_month_no" type="month" title="Month"/>
    <series key="_turn_over" groupBy="product" type="bar" title="TurnOver" aggregate="sum"/>
    <config name="xFormat" value="MM-YYYY"/>
  </chart>



  <chart stacked="true" name="chart.invoice.prod.qty.sold.history"
    title="Total Product Qty sold history by month by category"
    onInit="action.account.chart.set.from.to.date.month">
    <search-fields>
      <field type="date" name="fromDate" title="From Date" x-required="true"/>
      <field name="toDate" type="date" title="To Date" x-required="true"/>
    </search-fields>
    <dataset type="sql">

      SELECT
      to_char(_invoice._invoice_date,'yyyy-MM') AS _month_no,
      coalesce(_product._product_type,'other') AS product,
      coalesce(SUM(_invoice._turn_over), 00) AS
      _turn_over
      FROM
      (SELECT
      _invoice.id AS _invoice_id,
      _invoice.invoice_date AS _invoice_date,
      _line.qty AS _turn_over,
      _line.product AS _line_product
      FROM
      account_invoice AS _invoice
      JOIN
      account_invoice_line AS _line
      ON _line.invoice=_invoice.id
      JOIN
      auth_user AS _user
      ON _user.id =
      :__user__
      AND _invoice.company = _user.active_company
      WHERE
      _invoice.status_select = 3
      AND
      _invoice.invoice_date BETWEEN DATE(:fromDate) AND DATE(:toDate)
      AND
      _invoice.operation_type_select=3

      GROUP BY
      _invoice_id, _line_product, _turn_over
      ORDER BY
      _turn_over) AS _invoice

      JOIN

      (SELECT
      _category.name AS _product_type, _product.id AS _product_id
      FROM
      base_product AS _product
      JOIN
      base_product_category AS _category
      ON
      _product.product_category=_category.id AND _category.name IS NOT NULL) AS _product

      ON
      _invoice._line_product=_product._product_id

      GROUP BY _month_no, _product._product_type
      ORDER BY
      _month_no, _turn_over DESC

    </dataset>
    <category key="_month_no" type="month" title="Month"/>
    <series key="_turn_over" groupBy="product" type="bar" title="No of Units" aggregate="sum"/>
    <config name="xFormat" value="MM-YYYY"/>
  </chart>

  <chart name="chart.invoice.total.revenue.by.product"
    title="Total Revenue Distribution by Product"
    onInit="action.account.chart.set.from.to.date.month">
    <search-fields>
      <field type="date" name="fromDate" title="From Date" x-required="true"/>
      <field type="date" name="toDate" title="To Date" x-required="true"/>
    </search-fields>
    <dataset type="sql">
	  <![CDATA[
		SELECT
		_category.name AS _product_category,
			coalesce(SUM(CASE _invoice.operation_type_select
						WHEN 3 THEN _line.ex_tax_total
						WHEN 4 THEN -_line.ex_tax_total
						END), 0) AS _revenue
		FROM
			account_invoice_line AS _line
		JOIN
			account_invoice AS _invoice ON _invoice.id = _line.invoice
			AND (_invoice.operation_type_select=3 OR _invoice.operation_type_select=4)
			AND _invoice.invoice_date BETWEEN DATE(:fromDate) AND  DATE(:toDate)
		JOIN
			auth_user AS _user
			ON _user.id = :__user__
			AND _invoice.company = _user.active_company
		JOIN
			base_product AS _product ON _line.product = _product.id
		JOIN
			base_product_category AS _category ON _category.id = _product.product_category
		WHERE _invoice.status_select = 3
		GROUP BY
			_category.name
		ORDER BY
			_revenue DESC
	  ]]>
    </dataset>
    <category key="_product_category" type="text" title="Product Category"/>
    <series key="_revenue" type="donut" title="Revenue"/>
  </chart>

  <chart name="chart.total.revenue.by.geo.region" title="Reveue generated by country"
    onInit="action.account.chart.set.from.to.date.month">
    <search-fields>
      <field type="date" name="fromDate" title="From Date" x-required="true"/>
      <field type="date" name="toDate" title="To Date" x-required="true"/>
    </search-fields>
    <dataset type="sql">
	  <![CDATA[
		SELECT
			_country.name AS _geo_region,
			coalesce(SUM(CASE _invoice.operation_type_select
						WHEN 3 THEN _line.ex_tax_total
						WHEN 4 THEN -_line.ex_tax_total
						END), 0.00) AS _revenue
		FROM
			account_invoice_line AS _line
		JOIN
			account_invoice AS _invoice ON _invoice.id = _line.invoice AND (_invoice.operation_type_select=3 OR _invoice.operation_type_select=4)
		LEFT JOIN
			base_address AS _address ON _address.id = _invoice.address
		LEFT JOIN
			base_country AS _country ON _country.id = _address.addressl7country
		WHERE _invoice.status_select = 3
        AND _invoice.invoice_date BETWEEN DATE(:fromDate) AND DATE(:toDate)
		GROUP BY
			_geo_region
	  ]]>
    </dataset>
    <category key="_geo_region" type="text" title="Country"/>
    <series key="_revenue" type="donut" title="Revenue"/>
  </chart>



  <chart stacked="true" name="chart.purchase.buyer.dashboard.prod.qty.suppl.invoices.last.12m"
    title="Number Of Units On Supplier Invoices On Last 12 Month">
    <dataset type="sql">
      SELECT
      to_char(_invoice._invoice_date,'yyyy-MM') AS _month,
      coalesce(_product._product_type,'other') AS _product,
      SUM(_invoice._qty) AS _qty
      FROM
      (SELECT
      _invoice.id AS _invoice_id,
      _invoice.invoice_date AS _invoice_date,
      _line.qty AS _qty,
      _line.product AS _line_product
      FROM
      account_invoice AS _invoice
      JOIN
      account_invoice_line AS _line
      ON _line.invoice=_invoice.id
      WHERE
      _invoice.status_select = 3
      AND _invoice.invoice_date &gt;=
      now() - INTERVAL '12 month'
      AND _invoice.operation_type_select=1
      GROUP BY
      _invoice_id,
      _line_product, _qty, _invoice_date
      ORDER BY
      _qty) AS _invoice
      JOIN
      (SELECT
      _category.name AS
      _product_type, _product.id AS _product_id
      FROM
      base_product AS _product
      JOIN
      base_product_category AS _category
      ON _product.product_category=_category.id AND _category.name
      IS NOT NULL) AS _product

      ON _invoice._line_product=_product._product_id
      GROUP BY
      _product._product_type,_month
      ORDER BY _month
    </dataset>
    <category key="_month" type="month" title="Month"/>
    <series key="_qty" groupBy="_product" type="bar" title="Units"/>
    <config name="xFormat" value="MM-YYYY"/>
  </chart>


  <chart stacked="true"
    name="chart.purchase.buyer.dashboard.prod.turnover.suppl.invoices.last.12m"
    title="Turnover On Supplier Invoices On Last 12 Month">
    <dataset type="sql">
      SELECT
      to_char(_invoice._invoice_date,'yyyy-MM') AS _month,
      coalesce(_product._product_type,'other') AS _product,
      coalesce(SUM(_invoice._turn_over),00) AS
      _turn_over
      FROM
      (SELECT
      _invoice.id AS _invoice_id,
      _invoice.invoice_date AS _invoice_date,
      _line.company_ex_tax_total AS _turn_over,
      _line.product AS _line_product
      FROM
      account_invoice AS
      _invoice
      JOIN
      account_invoice_line AS _line
      ON _line.invoice=_invoice.id
      WHERE
      _invoice.status_select = 3
      AND _invoice.invoice_date &gt;= now() - INTERVAL '12 month'
      AND
      _invoice.operation_type_select=1

      GROUP BY
      _invoice_id, _line_product, _turn_over, _invoice_date
      ORDER BY
      _turn_over) AS _invoice
      JOIN
      (SELECT
      _category.name AS _product_type, _product.id AS
      _product_id
      FROM
      base_product AS _product
      JOIN
      base_product_category AS _category
      ON
      _product.product_category=_category.id AND _category.name IS NOT NULL) AS _product

      ON
      _invoice._line_product=_product._product_id
      GROUP BY _product._product_type,_month
      ORDER BY
      _month
    </dataset>
    <category key="_month" type="month" title="Month"/>
    <series key="_turn_over" groupBy="_product" type="bar" title="Units"/>
    <config name="xFormat" value="MM-YYYY"/>
  </chart>

  <chart name="chart.purchase.buyer.dashboard.supplier.invoices.per.month"
    title="Number Of Supplier Invoices Per Month">
    <dataset type="sql">

      SELECT
      to_char(_invoices._invoice_date,'yyyy-MM') AS _month,
      SUM(_invoices._amount) AS _amount
      FROM
      (SELECT
      count(_invoice.id) AS _amount,
      _invoice.invoice_date AS _invoice_date
      FROM
      account_invoice AS _invoice
      WHERE
      _invoice.invoice_date &gt;= now() - INTERVAL '12 month'
      AND _invoice.operation_type_select=1
      AND _invoice.status_select = 3
      GROUP BY
      _invoice_date) AS _invoices
      GROUP BY
      _month
      ORDER BY
      _month
    </dataset>
    <category key="_month" type="month" title="Month"/>
    <series key="_amount" type="bar" title="Units"/>
    <config name="xFormat" value="MM-YYYY"/>
  </chart>


  <chart name="chart.paymentVoucher.customer.paymentMode.distribution.nbr"
    onInit="action.account.chart.default.month.value"
    title="Customer Payment mode distribution by transactions">
    <search-fields>
      <field type="string" name="monthSelect" title="Historical Period"
        selection="account.year.period.duration.select" x-required="true"/>
    </search-fields>
    <dataset type="jpql">
	     <![CDATA[
	     	SELECT
	     		COUNT(self.id) AS total,
	     		_paymentMode.name AS paymentMode
	     	FROM
	     		PaymentVoucher self
	     	LEFT JOIN
	     		self.paymentMode AS _paymentMode
	     	WHERE
				self.operationTypeSelect=3
			AND
				self.paymentDate >= DATE(:todayDate) - (CAST(:monthSelect as int)*30)
			AND
				self.paymentDate <= DATE(:todayDate)
	     	GROUP BY
	     		_paymentMode

	    ]]>
    </dataset>
    <category key="paymentMode" type="text" title="Payment Mode"/>
    <series key="total" type="donut" title="Amount"/>
  </chart>

  <chart name="chart.invoice.terms.customer.paymentMode.distribution.nbr"
    title="Customer Payment mode distribution by transactions"
    onInit="action.account.chart.default.month.value">
    <search-fields>
      <field name="monthSelect" title="Historical Period" type="string"
        selection="account.year.period.duration.select" x-required="true"/>
    </search-fields>
    <dataset type="jpql"><![CDATA[

    	SELECT
    		COUNT(self.id) AS total,
    		_paymentMode.name AS paymentMode
    	FROM
    		InvoiceTerm self
          LEFT JOIN
            self.moveLine as _moveLine
          LEFT JOIN
            _moveLine.move as _move
          LEFT JOIN
            _moveLine.account as _account
          LEFT JOIN
            _account.accountType as _accountType
    	LEFT JOIN
    		self.paymentMode AS _paymentMode
    	WHERE
		self.isPaid = true AND ((_move.statusSelect IN (2,3) and
 _accountType.technicalTypeSelect = 'receivable' and _moveLine.debit = 0)) AND _move.functionalOriginSelect = 5
	AND
		self.dueDate >= DATE(:todayDate) - (CAST(:monthSelect as int)*30)
	AND
		self.dueDate <= DATE(:todayDate)
    	GROUP BY
    		_paymentMode


  ]]></dataset>
    <category key="paymentMode" type="text" title="Payment Mode"/>
    <series key="total" type="donut" title="Amount"/>
  </chart>


  <action-record name="action.account.chart.set.from.to.date.month"
    model="com.axelor.apps.account.db.Account">
    <field name="toDate" expr="eval:todayDate"/>
    <field name="fromDate" expr="eval: LocalDate.parse(todayDate).minusYears(1)"/>
    <field name="monthSelect" expr="eval:12"/>
  </action-record>

  <action-record model="com.axelor.apps.account.db.Account"
    name="action.account.chart.default.month.value">
    <field name="monthSelect" expr="eval:12"/>
  </action-record>

  <chart name="chart.paymentVoucher.customer.paymentMode.distribution.amount"
    title="Customer Payment mode distribution by amount"
    onInit="action.account.chart.default.month.value">
    <search-fields>
      <field name="monthSelect" title="Historical Period" type="string"
        selection="account.year.period.duration.select" x-required="true"/>
    </search-fields>
    <dataset type="jpql"><![CDATA[

    	SELECT
    		SUM(self.paidAmount) AS total,
    		_paymentMode.name AS paymentMode
    	FROM
    		PaymentVoucher self
    	LEFT JOIN
    		self.paymentMode AS _paymentMode
    	WHERE
		self.operationTypeSelect=3
	AND
		self.paymentDate >= DATE(:todayDate) - (CAST(:monthSelect as int)* 30)
	AND
		self.paymentDate <= DATE(:todayDate)
    	GROUP BY
    		_paymentMode


  ]]></dataset>
    <category key="paymentMode" type="text" title="Payment Mode"/>
    <series key="total" type="donut" title="Amount paid"/>
  </chart>


  <chart name="chart.invoice.terms.customer.paymentMode.distribution.amount"
    title="Customer Payment mode distribution by amount"
    onInit="action.account.chart.default.month.value">
    <search-fields>
      <field name="monthSelect" title="Historical Period" type="string"
        selection="account.year.period.duration.select" x-required="true"/>
    </search-fields>
    <dataset type="jpql"><![CDATA[

    	SELECT
    		SUM(self.amount) AS total,
    		_paymentMode.name AS paymentMode
    	FROM
    		InvoiceTerm self
          LEFT JOIN
            self.moveLine as _moveLine
          LEFT JOIN
            _moveLine.move as _move
          LEFT JOIN
            _moveLine.account as _account
          LEFT JOIN
            _account.accountType as _accountType
    	LEFT JOIN
    		self.paymentMode AS _paymentMode
    	WHERE
		self.isPaid = true AND (_move.statusSelect IN (2,3) and
	  _accountType.technicalTypeSelect = 'receivable' and _moveLine.debit = 0) AND _move.functionalOriginSelect = 5
	AND
		self.dueDate >= DATE(:todayDate) - (CAST(:monthSelect as int)* 30)
	AND
		self.dueDate <= DATE(:todayDate)
    	GROUP BY
    		_paymentMode


  ]]></dataset>
    <category key="paymentMode" type="text" title="Payment Mode"/>
    <series key="total" type="donut" title="Amount paid"/>
  </chart>


  <action-record name="action.account.active.fiscal.year"
    model="com.axelor.apps.account.db.Move">
    <field name="period"
      expr="eval: __repo__(Period).all().filter('self.year.company=?1 AND ?2 BETWEEN self.year.fromDate AND self.year.toDate AND self.statusSelect = 1 AND  self.year.typeSelect = 1',active_company,todayDate).fetchOne()"/>
    <field name="year"
      expr="eval: __repo__(Year).all().filter('self.id IN (select period.year from Period period where period.year.company=?1 AND ?2 BETWEEN period.year.fromDate AND period.year.toDate AND period.statusSelect = 1 AND  period.year.typeSelect = 1)',active_company,todayDate).fetchOne()"/>
  </action-record>

  <action-attrs
    name="action-acount-attrs-moveLines-revenues-expenses-chart-year-onchange">
    <attribute name="value" for="period" expr="eval: null"/>
  </action-attrs>

  <chart onInit="action.account.active.fiscal.year"
    name="chart.moveLines.revenues.vs.expenses" title="Revenues vs Expenses">

    <search-fields>
      <field name="year" type="reference" target="com.axelor.apps.base.db.Year"
        onChange="action-acount-attrs-moveLines-revenues-expenses-chart-year-onchange"
        domain="self.typeSelect=1" widget="many-to-one" title="Year" x-required="true"/>
      <field name="period" type="reference" target="com.axelor.apps.base.db.Period"
        widget="many-to-one" title="Period" domain="self.year=:year" x-required="true"/>
    </search-fields>

    <dataset type="jpql">

      SELECT
      SUM(
      (CASE
      WHEN self.account.accountType.technicalTypeSelect =
      'income' then self.credit
      WHEN self.account.accountType.technicalTypeSelect = 'charge' then
      self.debit
      END)
      ) AS _amount,
      (CASE
      WHEN
      (translation.message IS NULL OR translation.message = '')
      THEN item.title
      ELSE
      translation.message
      END) AS _label
      FROM
      MoveLine self,
      MetaSelect meta,
      MetaSelectItem item,
      MetaTranslation translation
      WHERE
      meta.name =
      'account.account.technical.type.select'
      AND item.select = meta AND
      self.account.accountType.technicalTypeSelect = item.value
      AND (self.move.statusSelect = 2 OR
      self.move.statusSelect = 3)
      AND self.move.period.year = :year
      AND (self.move.period = :period OR
      :period IS NULL)
      AND self.move.company = :active_company
      AND item.value IN ('income','charge')
      AND translation.key = item.title
      AND translation.language = :_language
      GROUP BY
      (CASE WHEN
      (translation.message IS NULL OR translation.message = '') THEN item.title
      ELSE
      translation.message
      END)
    </dataset>
    <category key="_label" type="text"/>
    <series key="_amount" type="bar" title="Amount"/>
  </chart>

  <chart onInit="action.account.chart.set.from.to.date.month"
    name="chart.invoice.sale.amount.by.month" title="Invoice Sale by month (tax excl.)">
    <search-fields>
      <field name="fromDate" type="date" title="From Date" x-required="true"/>
      <field name="toDate" type="date" title="To Date" x-required="true"/>
    </search-fields>
    <dataset type="sql">
      SELECT
      invoice_ex_tax_total - refund_ex_tax_total as ex_tax_total,
      _month
      FROM (
      SELECT
      coalesce(SUM(
      CASE
      WHEN self.operation_type_select=3 THEN self.ex_tax_total
      END
      ),0.00) AS invoice_ex_tax_total,
      coalesce(SUM(
      CASE
      WHEN self.operation_type_select=4 THEN
      self.ex_tax_total
      END
      ),0.00) AS refund_ex_tax_total,
      to_char(self.invoice_date,'yyyy-MM') AS
      _month
      FROM
      account_invoice self
      JOIN
      auth_user AS _user
      ON _user.id = :__user__
      JOIN
      base_company AS
      _company
      ON _company.id = _user.active_company
      AND _company.id = self.company
      WHERE
      self.status_select = 3 AND self.invoice_date BETWEEN DATE(:fromDate) AND DATE(:toDate)
      GROUP BY
      _month
      ORDER BY
      _month
      ) AS sub
    </dataset>
    <category key="_month" type="month" title="Month"/>
    <series key="ex_tax_total" type="bar" title="Amount"/>
    <config name="xFormat" value="MM-YYYY"/>
  </chart>

  <chart onInit="action.account.chart.set.from.to.date.month"
    name="chart.invoice.sale.amount.by.currency" title="Invoice Sale by currency (tax excl.)">
    <search-fields>
      <field name="fromDate" type="date" title="From Date" x-required="true"/>
      <field name="toDate" type="date" title="To Date" x-required="true"/>
    </search-fields>
    <dataset type="sql">
      SELECT
      coalesce(SUM(_account_invoice._ex_tax_total),0) AS ex_tax_total,
      _currency.name AS _currency
      FROM
      base_currency AS _currency
      CROSS JOIN (SELECT
      _invoice.ex_tax_total As _ex_tax_total,
      _invoice.currency AS _currency
      FROM account_invoice
      _invoice
      JOIN
      auth_user AS _user
      ON _user.id = :__user__
      JOIN
      base_company AS _company
      ON
      _company.id = _user.active_company
      AND _company.id = _invoice.company
      WHERE
      _invoice.operation_type_select = 3 AND _invoice.status_select = 3
      AND _invoice.invoice_date
      BETWEEN DATE(:fromDate) AND DATE(:toDate)
      ) AS _account_invoice
      WHERE
      _currency.id=_account_invoice._currency
      GROUP BY _currency.name
    </dataset>
    <category key="_currency" type="month" title="Month"/>
    <series key="ex_tax_total" type="bar" title="Amount"/>
  </chart>

  <chart onInit="action.account.chart.set.from.to.date.month"
    name="chart.invoice.sale.paymentCondition.distribution"
    title="Invoice Sale Payment Condition distribution">
    <search-fields>
      <field name="fromDate" type="date" title="From Date" x-required="true"/>
      <field name="toDate" type="date" title="To Date" x-required="true"/>
    </search-fields>
    <dataset type="sql">
      SELECT
      coalesce(SUM(_account_invoice._ex_tax_total),0) AS ex_tax_total,
      _payment_condition.name AS _payment_condition
      FROM
      account_payment_condition AS
      _payment_condition
      CROSS JOIN
      (SELECT _invoice.ex_tax_total As _ex_tax_total,
      _invoice.payment_condition AS _payment_condition
      FROM account_invoice _invoice
      JOIN
      auth_user AS
      _user
      ON _user.id = :__user__
      JOIN
      base_company AS _company
      ON _company.id = _user.active_company
      AND _company.id = _invoice.company
      WHERE _invoice.operation_type_select = 3 AND
      _invoice.status_select = 3
      AND _invoice.invoice_date BETWEEN DATE(:fromDate) AND DATE(:toDate)
      ) AS _account_invoice
      WHERE
      _payment_condition.id=_account_invoice._payment_condition
      GROUP BY
      _payment_condition.name
    </dataset>
    <category key="_payment_condition" type="month" title="Month"/>
    <series key="ex_tax_total" type="donut" title="Amount"/>
  </chart>

  <chart onInit="action.account.chart.set.from.to.date.month"
    name="chart.invoice.purchase.amount.by.month" title="Invoice Purchase by month (tax excl.)">
    <search-fields>
      <field name="fromDate" type="date" title="From Date" x-required="true"/>
      <field name="toDate" type="date" title="To Date" x-required="true"/>
    </search-fields>
    <dataset type="sql">

      SELECT
      coalesce(SUM(self.company_ex_tax_total),0.00) AS ex_tax_total,
      to_char(self.invoice_date,'yyyy-MM') AS _month
      FROM
      account_invoice self
      JOIN
      auth_user AS _user
      ON _user.id = :__user__
      JOIN
      base_company AS _company
      ON _company.id = _user.active_company
      AND
      _company.id = self.company
      WHERE
      self.status_select = 3 AND self.operation_type_select=1 AND
      self.invoice_date BETWEEN DATE(:fromDate) AND DATE(:toDate)
      GROUP BY _month
      ORDER BY
      _month
    </dataset>
    <category key="_month" type="month" title="Month"/>
    <series key="ex_tax_total" type="bar" title="Amount"/>
    <config name="xFormat" value="MM-YYYY"/>
  </chart>


  <chart onInit="action.account.chart.set.from.to.date.month"
    name="chart.invoice.purchase.amount.by.currency"
    title="Invoice Purchase by currency (tax excl.)">
    <search-fields>
      <field name="fromDate" type="date" title="From Date" x-required="true"/>
      <field name="toDate" type="date" title="To Date" x-required="true"/>
    </search-fields>
    <dataset type="sql">

      SELECT
      coalesce(SUM(_account_invoice._ex_tax_total),0) AS ex_tax_total,
      _currency.name AS _currency
      FROM
      base_currency AS _currency
      CROSS JOIN
      (SELECT
      _invoice.ex_tax_total As _ex_tax_total,
      _invoice.currency AS _currency
      FROM account_invoice
      _invoice
      JOIN
      auth_user AS _user
      ON _user.id = :__user__
      JOIN
      base_company AS _company
      ON
      _company.id = _user.active_company
      AND _company.id = _invoice.company
      WHERE
      _invoice.status_select = 3 AND _invoice.operation_type_select=1 AND
      _invoice.invoice_date
      BETWEEN DATE(:fromDate) AND DATE(:toDate)
      ) AS _account_invoice
      WHERE
      _currency.id=_account_invoice._currency
      GROUP BY _currency.name
    </dataset>
    <category key="_currency" type="text" title="Currency"/>
    <series key="ex_tax_total" type="bar" title="Amount"/>
  </chart>

  <chart onInit="action.account.chart.set.from.to.date.month"
    name="chart.invoice.purchase.paymentCondition.distribution"
    title="Invoice Purchase Payment Condition distribution">
    <search-fields>
      <field name="fromDate" type="date" title="From Date" x-required="true"/>
      <field name="toDate" type="date" title="To Date" x-required="true"/>
    </search-fields>
    <dataset type="sql">
      SELECT
      coalesce(SUM(_account_invoice._ex_tax_total),0) AS ex_tax_total,
      _payment_condition.name AS _payment_condition
      FROM
      account_payment_condition AS
      _payment_condition
      CROSS JOIN
      (SELECT _invoice.company_ex_tax_total As _ex_tax_total,
      _invoice.payment_condition AS _payment_condition
      FROM account_invoice _invoice
      JOIN
      auth_user AS
      _user
      ON _user.id = :__user__
      JOIN
      base_company AS _company
      ON _company.id = _user.active_company
      AND _company.id = _invoice.company
      WHERE _invoice.status_select = 3 AND
      _invoice.operation_type_select=1 AND
      _invoice.invoice_date BETWEEN DATE(:fromDate) AND
      DATE(:toDate)
      ) AS _account_invoice
      WHERE
      _payment_condition.id=_account_invoice._payment_condition
      GROUP BY
      _payment_condition.name
    </dataset>
    <category key="_payment_condition" type="text" title="Payment Condition"/>
    <series key="ex_tax_total" type="donut" title="Amount"/>
  </chart>

  <chart onInit="action.account.chart.set.from.to.date.month"
    name="chart.invoice.sale.refund.situation"
    title="Invoice and Refunds Sale situation (tax incl.)">
    <search-fields>
      <field name="fromDate" type="date" title="From Date" x-required="true"/>
      <field name="toDate" type="date" title="To Date" x-required="true"/>
    </search-fields>

    <dataset type="sql">

      SELECT
      coalesce(SUM(_sum),0.00) AS _amount,
      (CASE
      WHEN
      (translation.message_value IS NULL OR translation.message_value = '') THEN _label
      ELSE
      translation.message_value
      END) as _situation
      FROM
      (
      (SELECT
      'Invoices' as _label,
      self.in_tax_total
      as _sum
      FROM
      account_invoice AS self
      JOIN
      auth_user AS _user
      ON _user.id = :__user__
      JOIN
      base_company AS _company
      ON _company.id = _user.active_company
      AND _company.id = self.company
      WHERE
      self.status_select = 3 AND self.invoice_date BETWEEN DATE(:fromDate) AND DATE(:toDate)
      AND
      self.operation_type_select=3
      )
      UNION ALL
      (SELECT
      'Inv. Unpaid' as _label,
      self.company_in_tax_total_remaining as _sum
      FROM
      account_invoice AS self
      JOIN
      auth_user AS _user
      ON _user.id = :__user__
      JOIN
      base_company AS _company
      ON _company.id = _user.active_company
      AND
      _company.id = self.company
      WHERE
      self.status_select = 3 AND self.invoice_date BETWEEN
      DATE(:fromDate) AND DATE(:toDate) AND
      self.operation_type_select=3
      )
      UNION ALL
      (SELECT
      'Refunds' AS
      _label,
      self.in_tax_total AS _sum
      FROM
      account_invoice AS self
      JOIN
      auth_user AS _user
      ON _user.id =
      :__user__
      JOIN
      base_company AS _company
      ON _company.id = _user.active_company
      AND _company.id =
      self.company
      WHERE
      self.status_select = 3 AND self.invoice_date BETWEEN DATE(:fromDate) AND
      DATE(:toDate) AND
      self.operation_type_select=4
      )
      ) situation
      LEFT JOIN
      meta_translation as
      translation
      ON
      translation.message_key = _label AND translation.language = :_language
      GROUP BY
      _situation
      ORDER BY
      _situation

    </dataset>
    <category key="_situation" type="text" title="Situation"/>
    <series key="_amount" type="bar" title="Amount"/>
  </chart>

  <chart onInit="action.account.chart.set.from.to.date.month"
    name="chart.invoice.sale.situation" title="Invoice Sale situation (tax incl.)">

    <search-fields>
      <field name="fromDate" type="date" title="From Date" x-required="true"/>
      <field name="toDate" type="date" title="To Date" x-required="true"/>
    </search-fields>

    <dataset type="sql">

      SELECT
      coalesce(SUM(_sum),0.00) AS _amount,
      (CASE
      WHEN
      (translation.message_value IS NULL OR translation.message_value = '') THEN _label
      ELSE
      translation.message_value
      END) as _situation
      FROM
      (
      (SELECT
      'Invoiced Amount' as _label,
      self.in_tax_total as _sum
      FROM
      account_invoice AS self
      JOIN
      auth_user AS _user
      ON _user.id =
      :__user__
      JOIN
      base_company AS _company
      ON _company.id = _user.active_company
      AND _company.id =
      self.company
      WHERE
      self.status_select = 3 AND self.invoice_date BETWEEN DATE(:fromDate) AND
      DATE(:toDate) AND
      self.operation_type_select=3
      )
      UNION ALL
      (SELECT
      'Unpaid Inv. due' AS _label,
      self.company_in_tax_total_remaining AS _sum
      FROM
      account_invoice AS self
      JOIN
      auth_user AS _user
      ON _user.id = :__user__
      JOIN
      base_company AS _company
      ON _company.id = _user.active_company
      AND
      _company.id = self.company
      WHERE
      self.status_select = 3 AND self.invoice_date BETWEEN
      DATE(:fromDate) AND DATE(:toDate) AND
      self.due_date &lt; CURRENT_DATE AND
      self.operation_type_select=3
      )
      ) situation
      LEFT JOIN
      meta_translation as translation
      ON
      translation.message_key = _label AND translation.language = :_language
      GROUP BY
      _situation
      ORDER
      BY
      _situation

    </dataset>
    <category key="_situation" type="text" title="Situation"/>
    <series key="_amount" type="bar" title="Amount"/>
  </chart>

  <chart onInit="action.account.chart.set.from.to.date.month"
    name="chart.invoice.purchase.situation" title="Invoice Purchase situation (tax incl.)">

    <search-fields>
      <field name="fromDate" type="date" title="From Date" x-required="true"/>
      <field name="toDate" type="date" title="To Date" x-required="true"/>
    </search-fields>

    <dataset type="sql">

      SELECT
      coalesce(SUM(_sum),0.00) AS _amount,
      (CASE
      WHEN
      (translation.message_value IS NULL OR translation.message_value = '') THEN _label
      ELSE
      translation.message_value
      END) as _situation
      FROM
      (
      (SELECT
      'Invoiced Amount' as _label,
      self.company_in_tax_total as _sum
      FROM
      account_invoice AS self
      JOIN
      auth_user AS _user
      ON _user.id
      = :__user__
      JOIN
      base_company AS _company
      ON _company.id = _user.active_company
      AND _company.id =
      self.company
      WHERE
      self.status_select = 3 AND self.invoice_date BETWEEN DATE(:fromDate) AND
      DATE(:toDate) AND
      self.operation_type_select=1
      )
      UNION ALL
      (SELECT
      'Unpaid Inv. due' AS _label,
      self.company_in_tax_total_remaining AS _sum
      FROM
      account_invoice AS self
      JOIN
      auth_user AS _user
      ON _user.id = :__user__
      JOIN
      base_company AS _company
      ON _company.id = _user.active_company
      AND
      _company.id = self.company
      WHERE
      self.status_select = 3 AND self.invoice_date BETWEEN
      DATE(:fromDate) AND DATE(:toDate) AND
      self.due_date &lt; DATE(:todayDate) AND
      self.operation_type_select=1
      )
      ) situation
      LEFT JOIN
      meta_translation as translation
      ON
      translation.message_key = _label AND translation.language = :_language
      GROUP BY
      _situation
      ORDER
      BY
      _situation

    </dataset>
    <category key="_situation" type="text" title="Situation"/>
    <series key="_amount" type="bar" title="Amount"/>
  </chart>

  <custom name="action-invoice-term-view-payment-session-group-by-partner-dashlet-custom"
    title="Custom">

    <field name="amount" type="decimal" x-scale="2"/>

    <dataset type="jpql"><![CDATA[
	 select round(sum(self.amountPaid),2) as amount, _partner.name as supplier, _bankDetails.fullName as bankDetails
	 from InvoiceTerm as self
	 left join self.moveLine.partner as _partner
	 left join self.bankDetails as _bankDetails
	 where self.isSelectedOnPaymentSession = true and self.paymentSession.id = :_id
	 group by _partner.id,_bankDetails.id
	 order by _partner.name
	 ]]></dataset>

    <template><![CDATA[
	<report-table data='data' columns='supplier,bankDetails,amount' sums='amount'></report-table>
	 ]]></template>

  </custom>
</object-views>
